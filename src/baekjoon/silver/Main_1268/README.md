### ℹ️ 문제 정보
  - 번호 : 1268
  - 난이도 : Silver
  - 분류 : 구현, 완전탐색

### 🔎 문제 접근
한 학생이 1 ~ 5학년 동안 같은 반이었던 학생 수를 구하고,
그 수가 가장 많은 학생을 임시 반장으로 선정
  - 완전탐색 사용
  - 학년이 아닌 학생을 기준으로 비교
  - 학생 A와 B를 비교, 한 번이라도 같은 반이면 count 증가

<br />

### 📝 사용한 자료구조
- List<>[]
  - 기존에 2차원 배열을 사용 했으나, indexOf의 필요성 판단
  - 학생별 학년 정보를 개별 리스트로 저장

<br />

###  🦾 개선 포인트
- List<>[]사용
  - 학생 수, 학년 수가 고정돼있어 굳이 List 필요 없음
  - 2차원 배열이 더 직관적
- 입력 방식 개선
  - 문자열로 받고 split 사용은 불필요하게 느림
  - nextInt() 직접 입력
- 최대값 찾기 로직 단순화 필요
  - 단순히 > 비교 만으로 정리 가능
 <img width="244" height="38" alt="image" src="https://github.com/user-attachments/assets/7c1e1ae3-9fdd-492d-bc12-1f3d030f3fdf" />

        String line = scanner.nextLine();
        String[] split = line.split(" ");
### 비교
  String line = scanner.nextLine();
  String[] split = line.split(" ");
<br />

###  💡 배운 점
처음에는 문제 조건을 잘못 이해하지 못한 상태에서 구현부터 시작했다. 그 결과, 불필요한 로직이 추가되었고 문제를 단순하게 볼 수 있었음에도 구조를 복잡하게 설계하게 되었음. 최대값 찾기는 단순한 비교만으로도 충분히 해결이 가능하며, 구현 전 문제 조건을 정확히 분석하는 과정이 얼마나 중요한지 다시 깨달

 - 구현 문제는 자료구조 선택이 핵심
   - 문제 조건이 고정되어 있다면 단순한 구조가 더 좋음
 - 최대값 찾기 로직은 항상 "가장 단순한 형태" 생각







