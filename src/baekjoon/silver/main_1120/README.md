### ℹ️ 문제 정보
  - 번호 : 1268
  - 난이도 : Silver
  - 분류 : 구현, 완전탐색
    
<br />

### 🔎 문제 접근
작은 문자열을 큰 문자열 위에서 왼쪽부터 오른쪽까지 이동시키며 비교,
각 위치에서 서로 다른 문자 개수를 계산 후 최소 차이값을 갱신

- 이동 가능 범위 : 큰 문자열의 길이 - 작은 문자열의 길이
- 각 위치마다 문자 하나씩 비교 후 다른 문자 수 카운트
- 최소 값 유지

    
<br />

### 📝 사용한 자료구조
- String
  - 문자열 비교 charAt() 활용
- 별도의 자료 구조 없이 변수 사용
    
<br />

###  📘 개선 포인트
- substring()제거
  - substring()으로 부분 문자열을 생성 후 비교 -> 문자열 객체가 반복 생성되므로 비효율적
  - large.charAt(i + j) 방식으로 직접 비교하도록 수정
- 조기 종료(가지치기 추가)
  - 현재 diffCount가 이미 minDiff 이상이면 해당 위치는 최소값 후보가 될 수 없으므로 반복 중단
- 변수명 개선
  - overlapCount → diffCount
    minOverlapCount → minDiff
    
<br />

###  💡 배운 점
처음에는 단순히 구현에 집중하여 substring()을 사용해 비교하였다. 하지만 문제의 핵심은 부분 문자열 생성이 아니라 문자 단위 비교라는 점을 깨달음
 - 문자열 문제는 인덱스 기반 접근이 더 효율적일 수 있음
 - 완전탐색에서도 불필요한 연산은 줄일 수 있음 (가지치기)
 - 최대값 찾기 로직은 항상 "가장 단순한 형태" 생각
