### ℹ️ 문제 정보
  - 번호 : 1268
  - 난이도 : Silver
  - 분류 : 구현, 완전탐색
    
<br />

### 🔎 문제 접근
한 학생이 1 ~ 5학년 동안 같은 반이었던 학생 수를 구하고,
그 수가 가장 많은 학생을 임시 반장으로 선정
  - 완전탐색 사용
  - 학년이 아닌 학생을 기준으로 비교
  - 학생 A와 B를 비교, 한 번이라도 같은 반이면 count 증가
    
<br />

### 📝 사용한 자료구조
- List<>[]
  - 기존에 2차원 배열을 사용 했으나, indexOf의 필요성 판단
  - 학생별 학년 정보를 개별 리스트로 저장
    
<br />

###  🦾 개선 포인트
- List<>[]사용
  - 학생 수, 학년 수가 고정돼있어 굳이 List 필요 없음
  - 2차원 배열이 더 직관적
- 입력 방식 개선
  - 문자열로 받고 split 사용은 불필요하게 느림
  - nextInt() 직접 입력
- 최대값 찾기 로직 단순화 필요
  - 단순히 > 비교 만으로 정리 가능
    
<br />

###  💡 배운 점
처음에는 문제 조건을 잘못 이해하지 못한 상태에서 구현부터 시작했다. 그 결과, 불필요한 로직이 추가되었고 문제를 단순하게 볼 수 있었음에도 구조를 복잡하게 설계하게 되었음. 최대값 찾기는 단순한 비교만으로도 충분히 해결이 가능하며, 구현 전 문제 조건을 정확히 분석하는 과정이 얼마나 중요한지 깨달음
 - 구현 문제는 자료구조 선택이 핵심
   - 문제 조건이 고정되어 있다면 단순한 구조가 더 좋음
 - 최대값 찾기 로직은 항상 "가장 단순한 형태" 생각


🧠 네 풀이의 사고 과정 평가

네가 남긴 주석을 보면:

작은 문자열을 왼쪽/오른쪽으로 밀어서 비교

이 사고 방식 완전 정확해.
이 문제는 “문자열 정렬 문제”가 아니라

모든 가능한 정렬 위치를 탐색하는 문제

그걸 정확히 캐치했어.

📄 README 구성 아이디어

지금 말한 구조 좋다 👍
“내 사고 흐름” + “보완된 점” 형식 좋음.

아래 템플릿 바로 써도 됨.

📘 README 예시 (복붙용)
🔹 문제 접근 방식

작은 문자열을 큰 문자열 위에서 왼쪽부터 오른쪽까지 이동시키며 비교

각 위치에서 서로 다른 문자 개수를 계산

최소 차이값을 갱신하는 방식으로 해결

🔹 핵심 아이디어

큰 문자열의 길이 - 작은 문자열의 길이 만큼 이동 가능

각 위치마다 문자 하나씩 비교

다른 문자 수를 카운트

최소값 유지

🔹 내가 처음 작성한 코드의 특징

substring()을 사용하여 부분 문자열 생성 후 비교

모든 위치에 대해 완전 탐색 수행

문제 요구사항을 정확히 구현

🔹 개선한 부분

substring() 제거 → charAt(i + j) 직접 비교

변수명 명확화 (diffCount, minDiff)

현재 최소값보다 커지면 비교 중단 (조기 종료)

🔹 배운 점

문자열 문제는 슬라이딩 윈도우 방식으로 접근 가능

substring은 생각보다 비용이 발생할 수 있음

작은 최적화로 코드 가독성과 성능을 함께 개선할 수 있음






